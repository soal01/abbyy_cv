## Медианный фильтр
Было реализовано три алгоритма медианного фильтра: 
* наивный подсчет медианы - simpleMedianFilter
* алгоритм Huang et al. - linearMedianFilter
* constant time O(1) - constantMedianFilter

### Оценка фактической сложности алгоритмов:
Здесь H,W - высота и ширина изображения в пикселях
* Наивный алгоритм: для каждого пикселя и каждого канала в отдельности добавляем все пиксели одним проходом в массив и сортируем его. Пусть $n=(2*r+1)*(2*r+1)$ - количество пикселей в одном окне, где r - радиус окна. Тогда время работы алгоритма $O(W*H*3*n*log n)$. По памяти мы выделяем память только под массив, который сортируем, значит памяти мы тратим $O(n)$.
* Линейный алгоритм: в начале каждой строки считаем гистограмму для первого пикселя строки для каждого канала поотдельности. Это $O(n+С)$. Далее для каждого пикселя проходимся по по колонке, которую удаляем из окна и колонке,которую добавляем, после этого сдвигаем медиану. Это $O(2*(2*r+1) + C)$, где $С=256$ - количество всевозможных значений медианы. Итого получаем время работы $O(H*(n+(W-1)*(2*(2*r+1) + C)))$. По памяти  - мы храним гистограммы для каждого канала + несколько чисел для хранения медианы и количества элементов меньших, чем медиана итого: $O(С*3)$
* Константный алгоритм. Сначала инициализируем все гистограммы колонок. Это $O(W*(2*r+1))$. Далее в начале каждой строки обновляем гистограммы первых $2*r+1$ колонок и складываем эти гистограммы для получения текущей гистограммы. Это $O((2*r+1)*С+C)$. Далее для каждого следующего пикселя мы обновляем гистограмму для нового столбца, вычитаем гистограмму старого столбца и добавляем гистограмму нового столбца, после чего обновляем медиану - $O(3*C)$.
Итоговая временная сложность $O(W*(2*r+1) + H*((2*r+1)*С+C + (W-1)*3*C))$. Из памяти мы тратим память на хранение текущей гистограммы и гистограмм столбцов. Итого по памяти: $O((W+1)*C)$

### Оптимальная композиция алгоритмов:
Из графиков времени работы видно, что время работы наивного алгоритма растет очень быстро и его для быстрой работы не следует использовать. Линейный алгорит быстр на относительно маленьких окнах, но его время работы линейно растет от размера окна. Константный же алгоритм долго работает на маленьких окнах, однако  рост этого окна на скорости его работы почти никак не сказывается и судя по графикам уже где-то после радиуса окна 50 быстрее работает константный алгоритм. Итоговая композиция: если радиус окна меньше 50, то применяем линейный алгоритм, иначе - константный.


